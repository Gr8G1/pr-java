package Gr8G1.prac.section;

public class PrClass {
  /*
   * # JVM (Java Virtual Machine)
   *  - Java 는 OS에 종속적이지 않는 특징을 갖고, 특징과 같이 OS 위에서 Java 를 실행하기 위해 사용되는것이 JVM이다.
   *  > OS에 종속받지 않고 CPU 가 Java를 인식, 실행할 수 있게 하는 가상 기기이다.
   *  - 는 CPU가 인식을 하지 못하므로 기계어로 컴파일이 필요하다.
   *    > 처리 과정 순서
   *      1. Java compiler 가 Java 원시코드(*.java)를 클래스파일(*.class)로 변환
   *      2. 전달된 클래스파일(*.class)을 JIT(just-in-time compliation) 컴파일러를 이용해 OS가 인식 가능한 기계어로 전환한다.
   *  - Java compiler는 JDK를 설치하면 bin 에 존재하는 javac.exe를 말한다.
   *
   * 구조
   *  - 클래스 로더(Class Loader)
   *    - JVM 내로 클래스 파일(*.class)을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
   *    - 런 타임시 동적으로 클래스를 로드하고 jar 파일 내 저장된 클래스들을 JVM 위에 탑재
   *  - 실행 엔진(Execution Engine)
   *    - 클래스 로더에 의해 메모리에 적재된 클래스(Bytecodes)들을 기계어로 변경해 명령어 단위로 실행하는 역할을 하며, 아래 2가지 방식으로 실행한다.
   *      1. 인터프리터(Interpreter)
   *        - 명령어 단위로 읽어서 실행 (한줄씩 처리)
   *          > 실행 속도가 느리다는 단점이이있다.
   *      2 .JIT 컴파일러(Just-in-Time)
   *        - 인터프리터 방식으로 실행되다 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경,
   *          이후 더 이상 인터프리팅 하지 않고 기계어로 직접 실행하는 방식이다.
   *    - 가비지 콜렉터(Garbage collector)
   *      - 더이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제하는 역할을 수행한다.
   *  - 런타임 데이터 영역 (Runtime Data Area)
   *    - ! 아래 내용 참조
   *  - PC Register
   *    - 쓰레드가 생성될 때마다 생성되는 영역으로 현재 쓰레드가  실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. 이것을 이용해 쓰레드를 돌아가며 수행할 수 있게 한다.
   *
   * # 런타임 데이터 영역(Runtime Data Area)
   *  - 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간으로
   *    이렇게 할당받은 메모리를 JVM은 용도에 따라 아래와 같이 구분하여 관리한다.
   *
   * 낮은 주소(low memory)   -----------메모리---------
   *                        |    클래스/클래스 변수    | (메소드 영역)
   *                        |      객체 인스턴스       |   (힙 영역)
   *                        |                          |      ||
   *                        |   메소드(지역/매개)변수  |  (스택 영역)
   * 높은 주소(high memory)  --------------------------
   *
   *
   * 메소드(method) 영역: 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역
   *  - 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽어들여,
   *    해당 클래스에 대한 정보를 메소드 영역에 저장한다.
   *
   * 힙(heap) 영역 : 모든 인스턴스 변수가 저장되는 영역
   *  - new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장한다.
   *    힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
   *
   * 스택(stack) 영역 : 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역
   *  - 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장한다.
   *    스택 영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸한다.
   *    스택 영역에 저장되는 메소드의 호출 정보를 스택 프레임(stack frame)이라 하고,
   *    스택은 데이터 저장(push), 데이터를 인출(pop) 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작한다.
   *    메모리의 높은(아래) 주소에서 낮은(위) 주소의 방향으로 할당한다.
   *
   */

  /*
   * # 필드 타입별 초기화 정보
   *
   *  > [타입: 초기화값]
   *  - byte: 0
   *  - char: \u0000(빈 공백)
   *  - short: 0
   *  - int: 0
   *  - long: 0
   *  - float: 0.0F
   *  - double: 0.0
   *  - boolean: false
   *  - 참조형(Array/Class/interface): null
   *
   */

  /*
   * # 클래스(Class)
   *
   * 구성 요소
   *  - 필드(field) - (Member)
   *    - 클래스 변수
   *      - 초기화 여부: O
   *      - 생성시기: 클래스가 메모리에 올라갈때
   *      - 소멸시기: 프로그램이 종료될때
   *      - 저장 메모리: Method 영역
   *    - 인스턴스 변수
   *      - 초기화 여부: O
   *      - 생성시기: 인스턴스가 생성될 때
   *      - 소멸시기: 인스턴스가 소멸할 때
   *      - 저장 메모리: Heap 영역
   *    - 지역 변수
   *      - 초기화 여부: X
   *      - 생성시기: 블록({}) 내에서 변수 선언문이 실행될 때
   *      - 소멸시기: 블록({})을 벗어날 때
   *      - 저장 메모리: Stack 영역
   *  - 메소드(method)
   *    - 시그니처
   *      - [접근 제어자] [static] [final] 타입 이름 [= 초기화 값];
   *    - 메소드 오버로딩
   *      - 같은 이름의 메소드를 중복하여 정의하는 것을 의미한다.
   *    - 메소드 오버로딩 요구조건
   *        1. 메소드의 이름이 같아야 한다.
   *        2. 매개변수의 개수 또는 타입이 달라야 한다.
   *           > 반환 타입은 영향을 미치지 않는다.
   *    - 메소드 오버라이딩
   *      - 상위 클래스로부터 상속받은 메서드와 동일한 이름의 메서드를 재정의하는 것을 의미한다.
   *    - 메소드 오버라이딩 요구조건
   *        1. 메소드 선언부(메서드 이름, 매개변수, 반환타입)가 일치 해야된다.
   *        2. 메소드 접근제어자의 범위는 같거나 넓어야 한다.
   *        3. 상위 메소드 예외 처리 범위보다 넓을 수 없다.
   *
   *  - 생성자(constructor)
   *    - 생성자는 오버로딩이 가능하다.
   *    - 생성자 미 선언시 자동 생성된다.
   *    - 생성자 명은 클래스명과 동일해야 한다.
   *    - 인스턴스 변수의 초기화에 사용된다.
   *  - 중첩 클래스(nested) / 내부 클래스(inner) / 지역 클래스(local)
   *    - 큰 틀로 바라보면 객체를 생성(사용)을 위한 하나의 방법이라 봐도 무방하다.
   *
   * ~ 생성자를 제외한 나머지 3가지 요소를 클래스 멤버(member)라 칭한다.
   *
   * this
   *  - 모든 메서드에는 자신이 포함된 클래스의 객체를 가리키는 "this" 라는 참조변수가 존재한다.
   *  - "this"는 멤버 변수 접근시 생략 가능하나 필드명과 지역변수를 구분하기 위한 용도로 사용 권장.
   *
   * this()
   *  - 생성자 상호(추가) 호출에 사용된다.
   *  - ! 주의: 생성자의 내부에서만 사용할 수 있다.
   *  - ! 주의: 반드시 생성자의 첫 줄에 위치해야 한다.
   *  - ! 생성자 첫 줄에 this()가 없는 경우 컴파일러가 자동으로 this()를 삽입한다. 이때 클래스에 *기본생성자*가 없으면 에러가 발생한다.
   *
   * 익명 클래스
   *  - 클래스 정의와 객체 생성을 동시에 수행 (1회성 요소에 사용)
   *  - 클래스명은 조상(Object | interface)의 이름을 사용한다.
   * > new Object() { ... }
   *
   */

  PrClass() { // 생성자
    this("생성자를 호출합니다."); // 생성자 호출
  }
  PrClass(String s) { // 생성자 오버로딩
    System.out.println(s);
  }

  static String sf = "static field"; // 필드 (클래스 변수)
  String instf = "instance field"; // 필드 (인스턴스 변수)

  static void sClassMethod() {} // 메소드 (클래스 메소드)
  void iMethod() { // 메소드 (인스턴스 메소드)
    String instf = "local";

    System.out.println(this.instf); // -> "instance field"
    System.out.println(instf); // -> "local"
  }
  void iMethod(int i) {} // 메소드 오버로딩

  static class nClass {} // 중첩 클래스
  class iClass {} // 이너 클래스

  public static void main(String[] args) {
    PrClass iPrClass = new PrClass(); // 인스턴스화
    PrClass.nClass nClass = new PrClass.nClass(); // 중첩 클래스 인스턴스화
    PrClass.iClass iClass = iPrClass.new iClass(); // 내부 클래스 인스턴스화

    System.out.println(iPrClass);
    System.out.println(nClass);
    System.out.println(iClass);
  }
}
